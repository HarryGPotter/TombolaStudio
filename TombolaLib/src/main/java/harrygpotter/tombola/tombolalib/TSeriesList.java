/*
 * Copyright (c) 2018 Harry G potter (harry.g.potter@gmail.com)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 * associated documentation files (the "Software"), to deal in the Software without restriction, 
 * including without limitation the rights to use, copy, modify, merge, publish, distribute, 
 * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or 
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
 * NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
package harrygpotter.tombola.tombolalib;

import java.io.Serializable;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * This class is used to collect series of cards, as they are generated by
 * {@linkplain ISetFactory} objects.&nbsp;Each series of card contains 6 cards
 * having no number in common. TSeriesList objects implements
 * TList&lt;TSeries&gt; interface, it is a full java List, <i>iterable</i>
 * object. In addition, some specific methods and attributes have been added to
 * manage card series specific operations, such as setting progressive labels of
 * each card within the set, controls equal numbers between cards, etc.
 *
 * @author Harry G. Potter harry.g.potter@gmail.com
 * @version 1.1
 * @see TCard
 * @see ISetFactory
 * @see TMakeSix
 * @see TFileFormatter
 * @since 1.8
 */
public class TSeriesList extends ArrayList<TSeries> implements List<TSeries>, Serializable {

    private static final String DEFAULT_LABEL_PREFIX = "AA";
    private static final String DEFAULT_LABEL_DELIMITER = "-";

    /**
     * List the supported choices you have to number cards when preparing their
     * labels
     */
    public static enum TLabelingModes {
        /**
         * Label are prepared numbering sequentially each card: the label will
         * be in the format &lt;label-prefix&gt; &lt;separator character&gt;
         * &lt;card cumber&gt; &lt;separator&gt; &lt;checksum&gt;
         */
        BYCARDS,
        /**
         * Label are prepared numbering sequentially each card: the label will
         * be in the format &lt;label-prefix&gt; &lt;separator character&gt;
         * &lt;series cumber&gt; &lt;separator&gt; &lt;card ordinal within the
         * series&gt; &lt;separator&gt; &lt;checksum&gt;
         */
        BYSERIES
    };

    private String name;
    private String labelPrefix;
    private ZonedDateTime creationTimeStamp;
    private long ts_creation;
    private long changes_elapsed;

    private String makeSixMethod;
    private long makeSixSeed;
    private long makeSixCounter;

    private String setFactoryMethod;

    private int maxepc;
    private int maxepr;

    private List<String> comments;

    /**
     * Create an empty series list object, configuring a descriptive short name
     * for this list of series.
     *
     * @param name a short, descriptive name that can be used to identify the
     * list of series.
     */
    public TSeriesList(String name) {
        this(name, DEFAULT_LABEL_PREFIX);
    }

    /**
     * Create an empty series list object, setting the string passed in input as
     * the prefix for the labels of each cards within this set (see
     * {@linkplain TSeriesList#prepareLabels()} for further info).
     *
     * @param name a short, descriptive name that can be used to identify the
     * list of series.
     * @param labelPrefix the prefix to use to label cards within this set
     */
    public TSeriesList(String name, String labelPrefix) {
        super();
        this.name = name;
        this.creationTimeStamp = ZonedDateTime.now();
        if (labelPrefix != null) {
            this.labelPrefix = labelPrefix;
        } else {
            this.labelPrefix = "";
        }
        this.maxepc = 0;
        this.maxepr = 0;
        this.ts_creation = System.currentTimeMillis();
    }

    /**
     * Return the descriptive name of the series list, as specified at
     * construction time.
     *
     * @return the descriptive name of the series set.
     */
    public String getName() {
        return this.name;
    }

    /**
     * TSeriesList objects comprise a string array where users can store any
     * free, textual comment they want to maintain together with series within
     * the set, such as info related to the creation processes, purposes of the
     * set, etc.&nbsp;Comments will be saved within the file by {@linkplain
     * TFileFormatter} methods.
     *
     * @param comment a comment text line you want to maintain within the series
     * set.
     */
    public void addComment(String comment) {
        if (comments == null) {
            comments = new ArrayList<>();
        }
        comments.add(comment);
        // return comments.size();
    }

    /**
     * Return the list of comments added to this set of series
     *
     * @return the list of comments added to this set of series
     */
    public List<String> getComments() {
        return comments;
    }

    /**
     * Return the total number of series of cards generated (and eventually
     * discarded) by the seriesBuilder object (see {@linkplain TMakeSix}) used
     * to prepare this list of series.&nbsp;It is just an helper attribute, set
     * by {@linkplain ISetFactory} objects at the end of the series generation
     * process.
     *
     * @return the overall total number of series of cards generated to prepare
     * this list of cards.
     */
    public long getMakeSixCounter() {
        return makeSixCounter;
    }

    // Only package visibility
    void setMakeSixCounter(long makeSixCounter) {
        this.makeSixCounter = makeSixCounter;
    }

    /**
     * Return the name of the seriesBuilder method used to prepare this set of
     * series (see {@linkplain TMakeSix}).&nbsp;It is just an helper attribute,
     * set by {@linkplain ISetFactory} objects at the end of the series
     * generation process.
     *
     * @return the name of the seriesBuilder method used to prepare this set of
     * series.
     */
    public String getMakeSixMethod() {
        return makeSixMethod;
    }

    // Only package visibility
    void setMakeSixMethod(String makeSixMethod) {
        this.makeSixMethod = makeSixMethod;
    }

    /**
     * Return the prefix used to generate progressive labels for the cards
     * within this set. See {@linkplain TSeriesList#prepareLabels()} for further
     * info about the use of this parameter.
     *
     * @return the prefix used to generate progressive labels for the cards
     * within this set
     */
    public String getLabelPrefix() {
        return this.labelPrefix;
    }

    /**
     * Set the text (usually a short string) to be used to generate progressive
     * labels uniquely assigned to each card within this set. See
     * {@linkplain TSeriesList#prepareLabels()} for further info about the use
     * of this parameter.
     *
     * @param labelPrefix the text prefix to use (usually a string few
     * characters long)
     * @see TSeriesList#prepareLabels()
     */
    public void setLabelPrefix(String labelPrefix) {
        if (labelPrefix != null) {
            this.labelPrefix = labelPrefix;
        } else {
            this.labelPrefix = "";
        }
        this.prepareLabels();
    }

    /**
     * Return the seed used to initialize the series builder object used to
     * prepare this set of series (see {@linkplain TMakeSix}).&nbsp;It is just
     * an helper attribute, set by {@linkplain ISetFactory} objects during the
     * series generation process.
     *
     * @return the seed used to initialize the series builder object used to
     * prepare this set of series.
     */
    public long getMakeSixSeed() {
        return makeSixSeed;
    }

    // Only package visibility
    void setMakeSixSeed(long makeSixSeed) {
        this.makeSixSeed = makeSixSeed;
    }

    /**
     * Return the name of the algorithm used to prepare this set of cards,
     * trying to optimally "randomize" the numbers of the cards.&nbsp;It is just
     * an helper attribute, set by {@linkplain ISetFactory} objects during the
     * series generation process.
     *
     * @return the name of the algorithm used to prepare this set of cards.
     */
    public String getSetFactoryMethod() {
        return this.setFactoryMethod;
    }

    // Only package visibility
    void setSetFactoryMethod(String setFactoryMethod) {
        this.setFactoryMethod = setFactoryMethod;
    }

    // Only package visibility
    void setCreationElapsedMillis(long elapsed) {
        this.changes_elapsed = elapsed;
    }

    /**
     * Just a little specialization of the standard add method for any
     * {@linkplain List} objects, needed to keep trace of the creation time for
     * the list.
     *
     * @param e the new TSeries object to add
     *
     * @return true is the series has been added, false otherwise
     */
    @Override
    public boolean add(TSeries e) {
        changes_elapsed = System.currentTimeMillis() - ts_creation;
        return super.add(e);
    }

    /**
     * Just a little specialization of the standard add method for any
     * {@linkplain List} objects, needed to keep trace of the creation time for
     * the list.
     *
     * @param index the position within the list where to add the new series
     * @param e the series object to add
     */
    @Override
    public void add(int index, TSeries e) {
        changes_elapsed = System.currentTimeMillis() - ts_creation;
        super.add(index, e);

    }

    /**
     * size() method has been overwritten in order to let it be synchronized and
     * therefore used, by other threads, to check the generation progresses.
     *
     * @return the number of series actually present in the SeriesList object
     */
    @Override
    public synchronized int size() {
        return super.size();
    }

    /**
     * Return the overall maximum amount of equal number verified between two
     * cards belonging to this list of series.&nbsp;It is a value within the
     * [0,15] range.
     *
     * @return the overall maximum equal number verified between two cards of
     * this list of series
     */
    public int getCurrentMEPC() {
        return maxepc;
    }

    /**
     * Return the overall maximum amount of equal number verified between two
     * distinct rows belonging to two cards within this list of series.&nbsp;It
     * is a value within the [0,5] range.
     *
     * @return the overall maximum amount of equal number verified between two
     * distinct rows within this list of series.
     */
    public int getCurrentMEPR() {
        return maxepr;
    }

    /**
     * Return the timestamp of the completion of the generation process for this
     * list of series.
     *
     * @return the timestamp of the completion of the generation process for
     * this list of series.
     */
    public ZonedDateTime getCreationTimeStamp() {
        return creationTimeStamp;
    }

    /**
     * Return the duration in milliseconds of the generation process of this
     * list of series.
     *
     * @return the duration in milliseconds of the generation process of this
     * list of series.
     */
    public long getCreationElapsedMillis() {
        return changes_elapsed;
    }

    /**
     * Compare each possible card couple within this list, counting and setting
     * within each series the maximum equal numbers found between them.&nbsp;See
     * {@linkplain TSeries#compareByCard(TSeries)} method for further info.
     *
     * @see TSeries#compareByCard(TSeries)
     */
    public void compareByCard() {
        compareByCard(0, this.size());
    }

    /**
     * Compare each possible card couple within a subset of this list of series,
     * counting and setting within each series the maximum equal numbers found
     * between them.&nbsp;See {@linkplain TSeries#compareByCard(TSeries)} method
     * for further info.
     *
     * @param from the index of the first series of the subset to be considered
     * for comparisons.
     * @param to the index of the first series EXCLUDED by the subset to be
     * considered for comparisons.
     *
     * @see TSeries#compareByCard(TSeries)
     */
    public void compareByCard(int from, int to) {
        int size = this.size();
        if ((to - from) <= 0 || from < 0 || to > size) {
            return;
        }
        for (int i = from; i < to; i++) {
            for (int j = i + 1; j < to; j++) {
                int temp1 = this.get(i).compareByCard(this.get(j));
                if (temp1 > maxepc) {
                    maxepc = temp1;
                }
            }
        }
    }

    /**
     * Compare each couple of cards of this list of series, counting and setting
     * within each series the maximum equal numbers found between their
     * rows.&nbsp; See {@linkplain TSeries#compareByRow(TSeries)} method for
     * further info.
     *
     * @see TSeries#compareByRow(TSeries)
     */
    public void compareByRow() {
        compareByRow(0, this.size());
    }

    /**
     * Compare each couple of cards of a subset of this list of series, counting
     * and setting within each series the maximum equal numbers found between
     * their rows.&nbsp; See {@linkplain TSeries#compareByRow(TSeries)} method
     * for further info.
     *
     * @param from the index of the first series of the subset to be considered
     * for comparisons.
     * @param to the index of the first series EXCLUDED by the subset to be
     * considered for comparisons.
     *
     * @see TSeries#compareByRow(TSeries)
     */
    public void compareByRow(int from, int to) {
        int size = this.size();
        if ((to - from) <= 0 || from < 0 || to > size) {
            return;
        }
        for (int i = from; i < to; i++) {
            for (int j = i + 1; j < to; j++) {
                int temp1 = this.get(i).compareByRow(this.get(j));
                if (temp1 > maxepr) {
                    maxepr = temp1;
                }
            }
        }
    }

    /**
     * Reset the values of max equal number by cards
     * ({@linkplain TSeries#getCurrentMaxEPC()}) and max equal card by row
     * ({@linkplain TSeries#getCurrentMaxEPR()}) for each series object within
     * this list of series.
     *
     * @see TSeriesList#compareByCard()
     * @see TSeriesList#compareByRow()
     */
    public void resetAllCompareResult() {
        this.forEach((s) -> {
            s.resetCompareResult();
        });
        this.maxepc = 0;
        this.maxepr = 0;
    }

    /**
     * Sort al the series within the list putting at the beginning the series
     * whose cards have less numbers equal to other cards (that is the lowest
     * maxEPC series value).&nbsp;In this way, is for a tombola game you do not
     * have to use all the series in the list, the probability to have
     * concurrent win should be minimized using the series in the order they are
     * in the list.
     */
    public void sortBestToWorstByCard() {
        this.sort((s1, s2) -> Integer.valueOf(s1.getCurrentMaxEPC()).compareTo(s2.getCurrentMaxEPC()));
        
    }

    /**
     * Sort al the series within the list putting at the beginning the series
     * whose card rows have less numbers equal to other card rows (that is the
     * lowest maxEPR series value).&nbsp;In this way, is for a tombola game you
     * do not have to use all the series in the list, the probability to have
     * concurrent win should be minimized using the series in the order they are
     * in the list.
     */
    public void sortBestToWorstByRow() {
        this.sort((s1, s2) -> Integer.valueOf(s1.getCurrentMaxEPR()).compareTo(s2.getCurrentMaxEPR()));
    }

    /**
     * This batch method assign a label to each card of the series list, using
     * default values for customization possibilities (see
     * {@linkplain TSeriesList#prepareLabels(int, int, String, TLabelingModes, boolean)}
     * for further info.
     *
     * @see TSeriesList#prepareLabels(int, int, String, TLabelingModes, boolean)
     */
    public void prepareLabels() {
        this.prepareLabels(0, this.size(), DEFAULT_LABEL_DELIMITER, TLabelingModes.BYCARDS, true);
    }

    /**
     * This batch method assign a label to each card of the specified subset of
     * series within this series list, allowing for some customization of the
     * method used to prepare each single label.
     *
     * @param start the first series index of the subset on which apply new
     * labels
     * @param end the first series index EXCLUDED by the subset on which apply
     * new labels
     * @param tagSeparator a short string, typically a single character of even
     * an empty string, used to separate different sub-components of the label
     * (that is, the prefix, the progressive number, the checksum)
     * @param mode specify the mode used to number the cards, that is BYCARDS
     * (each card is numbered independently) or BYSERIES (there is a number for
     * each series, followed by a number for each card of the series, thus from
     * 1 to 6).
     * @param ctrlCode if true a checksum is appended to the end of the label
     * @throws TTombolaRuntimeException if the start or end indexes passed in
     * input are outside the boundaries of the list
     */
    public void prepareLabels(int start, int end, String tagSeparator, TLabelingModes mode, boolean ctrlCode) throws TTombolaRuntimeException {
        if (start < 0 || start > this.size() || end < 0 || end > this.size()) {
            throw new TTombolaRuntimeException("<ERROR> Start and End value must be in the [0, " + this.size() + "] range.");
        }
        if (tagSeparator == null) {
            tagSeparator = "";
        }
        for (int i = start; i < end; i++) {
            for (int j = 0; j < 6; j++) {
                String label = this.labelPrefix;
                if (label.length() > 0) {
                    label += tagSeparator;
                }
                if (mode == TLabelingModes.BYCARDS) {
                    label += String.format("%03d", i * 6 + j + 1);
                } else {
                    label += String.format("S%03d" + tagSeparator + "C%d", i + 1, j + 1);
                }
                //TODO(2.0) Maybe it is possible to improve and add other modes to label cards...
                if (ctrlCode) {
                    label += tagSeparator;
                    label += this.get(i).getCard(j).evaluateCheckSum(0);
                }
                this.get(i).getCard(j).changeLabel(label);
            }
        }
    }

    /**
     * This method checks how many cards there are within the series list having
     * X maximum equal number by card and Y maximum equal number by row with
     * other cards within this same list of series, providing as returned
     * parameter a data structure containing counters for each X and Y values (X
     * within [0,16] range, Y within [0,5] range.&nbsp;<b>Pay Attention: this
     * method requires that
     * {@linkplain TSeriesList#compareByCard()} {@linkplain TSeriesList#compareByRow()}
     * have been previously called on the list.</b>
     *
     * @return a data structure containing counters for each possible values of
     * maxEPC and maxEPR values for each series of this series list.
     *
     * @see TSeries#compareByCard(TSeries)
     * @see TSeries#compareByRow(TSeries)
     * @see TSeriesList#compareByCard()
     * @see TSeriesList#compareByRow()
     */
    public TSeriesListStats seriesListStatistics() {
        if (this.isEmpty()) {
            return null;
        }
        int[] maxepc_distribution = new int[16];
        Arrays.fill(maxepc_distribution, 0);
        int[] maxepr_distribution = new int[6];
        Arrays.fill(maxepr_distribution, 0);
        this.forEach((sx) -> {
            for (int c = 0; c < 6; c++) {
                maxepc_distribution[sx.getCard(c).getCurrentMaxEPC()]++;
                maxepr_distribution[sx.getCard(c).getCurrentMaxEPR()]++;
            }
        });
        return new TSeriesListStats(maxepc_distribution, maxepr_distribution);
    }
}           // End Of File - Rel.(1.1)
